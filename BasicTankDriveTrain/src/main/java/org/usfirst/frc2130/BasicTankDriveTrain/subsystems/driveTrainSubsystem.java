// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2130.BasicTankDriveTrain.subsystems;


import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import org.usfirst.frc2130.BasicTankDriveTrain.Robot;
import org.usfirst.frc2130.BasicTankDriveTrain.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.SpeedControllerGroup;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class driveTrainSubsystem extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /* This section here is for declaring what your aspects will be, for example the rightMotorMaster is private, 
    so only used in this subsystem, and it is a WPI_TalonSRX, the motor type it uses, then the name of the aspect. -Cory */

    private WPI_TalonSRX rightMotorMaster;
    private WPI_TalonSRX rightMotorSlave;
    private WPI_TalonSRX leftMotorMaster;
    private WPI_TalonSRX leftMotorSlave;

    /* This section here is for declaring what your aspects will be, for example the diffDrive is private, 
    so only used in this subsystem, and it is a DifferentialDrive, the thing that it is, then the name of the aspect. -Cory */

    private DifferentialDrive diffDrive;

    public driveTrainSubsystem() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        //Here is where we define our previously named aspects. -Cory

        //We do this by calling the aspect by using it's name we gave it. In this case rightMotorMaster, then we set it equals
        //to a new WPI_TalonSRX, the number in the parenthesis is the can id, the number the computer uses to figure out what
        //motor does what -Cory

        rightMotorMaster = new WPI_TalonSRX(1);

        rightMotorSlave = new WPI_TalonSRX(2);

        leftMotorMaster = new WPI_TalonSRX(3);

        leftMotorSlave = new WPI_TalonSRX(4);

        follow();

        diffDrive = new DifferentialDrive(rightMotorMaster, leftMotorMaster);

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /*This is also a function, to make one you define if it is a public or private, private means that only this subsystem can
    use it and public means anything is allowed to access it, then you define the method type, the common ones are void, boolean
    and int, void causes no return, boolean means a true or false value, and int means that it returns a number, then you name it
    a RELEVENT name with open and closed parenthesis and then a open and closed braket. -Cory */

    //This method makes the motor slaves follow the motor master of their respective sides -Cory

    public void follow(){
        rightMotorSlave.follow(rightMotorMaster);
        leftMotorSlave.follow(leftMotorMaster);
    }

    //this method creates the drive train by creating a arcadedrive system. we call the motors by calling the diffDrive we made
    //then we place it under a arcade drive, then we call the certain joystick axis that we use for driving and another for turning
    // we do that by calling it from the Robot, then we call from the oi, then the controller we are getting it from and then
    //the axis that is. -Cory

    public void moveRobot(){
        diffDrive.arcadeDrive(Robot.oi.driverJoystick.getRawAxis(1), Robot.oi.driverJoystick.getRawAxis(4));
    }

}

